// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for Layer.
const (
	DB         Layer = "DB"
	DOC        Layer = "DOC"
	FRAMEWORK  Layer = "FRAMEWORK"
	LIB        Layer = "LIB"
	MIDDLEWARE Layer = "MIDDLEWARE"
	OS         Layer = "OS"
	OTHER      Layer = "OTHER"
	RUNTIME    Layer = "RUNTIME"
	TOOLBUILD  Layer = "TOOL_BUILD"
	TOOLDEV    Layer = "TOOL_DEV"
	TOOLTEST   Layer = "TOOL_TEST"
)

// Defines values for ReviewStatus.
const (
	Draft    ReviewStatus = "draft"
	Verified ReviewStatus = "verified"
)

// Defines values for Role.
const (
	ADMIN  Role = "ADMIN"
	EDITOR Role = "EDITOR"
	VIEWER Role = "VIEWER"
)

// Defines values for ScopeStatus.
const (
	INSCOPE      ScopeStatus = "IN_SCOPE"
	OUTSCOPE     ScopeStatus = "OUT_SCOPE"
	REVIEWNEEDED ScopeStatus = "REVIEW_NEEDED"
)

// Defines values for SupplierType.
const (
	INTERNALFORK SupplierType = "INTERNAL_FORK"
	REPACKAGE    SupplierType = "REPACKAGE"
	UPSTREAM     SupplierType = "UPSTREAM"
)

// Defines values for UsageRole.
const (
	BUILDONLY       UsageRole = "BUILD_ONLY"
	BUNDLEDBINARY   UsageRole = "BUNDLED_BINARY"
	BUNDLEDSOURCE   UsageRole = "BUNDLED_SOURCE"
	DEVONLY         UsageRole = "DEV_ONLY"
	DYNAMICLINK     UsageRole = "DYNAMIC_LINK"
	RUNTIMEREQUIRED UsageRole = "RUNTIME_REQUIRED"
	SERVERENV       UsageRole = "SERVER_ENV"
	STATICLINK      UsageRole = "STATIC_LINK"
	TESTONLY        UsageRole = "TEST_ONLY"
)

// Defines values for ExportProjectArtifactsParamsFormat.
const (
	Csv      ExportProjectArtifactsParamsFormat = "csv"
	SpdxJson ExportProjectArtifactsParamsFormat = "spdx-json"
)

// Layer OSS 技術レイヤ分類（OS=OS, LIB=ライブラリ 等）
type Layer string

// LoginResponse ログイン成功時のレスポンス
type LoginResponse struct {
	// AccessToken JWT アクセストークン。Authorization: Bearer にセットする
	AccessToken string `json:"accessToken"`

	// ExpiresIn トークンの有効期限（秒）
	ExpiresIn int `json:"expiresIn"`
}

// OssComponent OSS の論理的名称（バージョン共通情報）
type OssComponent struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ（新規利用抑止）
	Deprecated bool `json:"deprecated"`

	// Description 簡易説明 / メモ
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Id OSSコンポーネント ID
	Id openapi_types.UUID `json:"id"`

	// Layers 技術レイヤ分類（複数指定可）
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 表示名 / ユニーク（大文字小文字区別ポリシーは実装で決定）
	Name string `json:"name"`

	// NormalizedName 検索用正規化名称（小文字化・記号除去）
	NormalizedName *string `json:"normalizedName,omitempty"`

	// PrimaryLanguage 主言語（例: C, C++, Go, Java）
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl ソースリポジトリ（Git 等）URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// Tags 付与タグ一覧
	Tags *[]Tag `json:"tags,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// OssComponentCreateRequest OSSコンポーネント作成リクエスト
type OssComponentCreateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name OSS 表示名
	Name string `json:"name"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 初期付与するタグ ID 群
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssComponentUpdateRequest OSSコンポーネント更新リクエスト（部分）
type OssComponentUpdateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 新しい名称
	Name *string `json:"name,omitempty"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 置換後のタグ ID 配列
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssVersion 個別バージョン情報
type OssVersion struct {
	// CpeList CPE 文字列配列（脆弱性紐付け用）
	CpeList *[]string `json:"cpeList,omitempty"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// HashSha256 配布アーカイブ等の SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// Id バージョン ID
	Id openapi_types.UUID `json:"id"`

	// LastReviewedAt 最終レビュー日時
	LastReviewedAt *time.Time `json:"lastReviewedAt"`

	// LicenseConcluded 社内審査確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw SPDX 互換ライセンス式（上流取得時点）
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// OssId 親 OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// Purl package-url (例: pkg:maven/...)
	Purl *string `json:"purl"`

	// ReleaseDate 上流リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus ReviewStatus `json:"reviewStatus"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Version バージョン文字列 (SemVer 互換推奨)
	Version string `json:"version"`
}

// OssVersionCreateRequest バージョン作成リクエスト
type OssVersionCreateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// HashSha256 アーカイブ SHA-256
	HashSha256 *string `json:"hashSha256"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// Version バージョン文字列
	Version string `json:"version"`
}

// OssVersionUpdateRequest バージョン更新リクエスト（部分）
type OssVersionUpdateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// HashSha256 SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// LicenseConcluded 確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus *ReviewStatus `json:"reviewStatus,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`
}

// PagedResultOssComponent OSSコンポーネントページング結果
type PagedResultOssComponent struct {
	// Items 結果アイテム配列
	Items *[]OssComponent `json:"items,omitempty"`

	// Page 現在ページ (1 始まり)
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultOssVersion OSS バージョンページング結果
type PagedResultOssVersion struct {
	// Items 結果アイテム配列
	Items *[]OssVersion `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProject プロジェクト一覧ページング結果
type PagedResultProject struct {
	// Items 結果アイテム配列
	Items *[]Project `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProjectUsage プロジェクト利用レコードのページング結果
type PagedResultProjectUsage struct {
	// Items 結果アイテム配列
	Items *[]ProjectUsage `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultUser ユーザー一覧ページング結果
type PagedResultUser struct {
	Items *[]User `json:"items,omitempty"`
	Page  *int    `json:"page,omitempty"`
	Size  *int    `json:"size,omitempty"`
	Total *int    `json:"total,omitempty"`
}

// Problem RFC 9457 / RFC 7807 型エラー応答ボディ
type Problem struct {
	// Code アプリケーション独自エラーコード
	Code *string `json:"code"`

	// Detail 追加詳細メッセージ
	Detail *string `json:"detail"`

	// Errors フィールド単位バリデーションエラー配列
	Errors *[]struct {
		// Field エラーが発生したフィールド名（JSON Pointer など）
		Field *string `json:"field,omitempty"`

		// Message フィールドに対するエラーメッセージ
		Message *string `json:"message,omitempty"`
	} `json:"errors,omitempty"`

	// Instance エラーが発生した具体的インスタンス URI（トレースID等）
	Instance *string `json:"instance"`

	// Status HTTP ステータスコード
	Status int `json:"status"`

	// Title エラーの概要メッセージ（人間可読）
	Title string `json:"title"`

	// Type 問題タイプ識別 URI（拡張分類用）
	Type *string `json:"type"`
}

// Project プロジェクト（納品単位）
type Project struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryDate 納品予定日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 担当部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Id プロジェクト ID
	Id openapi_types.UUID `json:"id"`

	// Manager 責任者 / 担当者名
	Manager *string `json:"manager"`

	// Name プロジェクト名称
	Name string `json:"name"`

	// OssUsageCount 紐付く OSS 利用件数集計
	OssUsageCount *int `json:"ossUsageCount,omitempty"`

	// ProjectCode 社内識別コード（ユニーク）
	ProjectCode string `json:"projectCode"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// ProjectCreateRequest プロジェクト作成リクエスト
type ProjectCreateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name string `json:"name"`

	// ProjectCode ユニークなプロジェクトコード
	ProjectCode string `json:"projectCode"`
}

// ProjectUpdateRequest プロジェクト更新リクエスト
type ProjectUpdateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name *string `json:"name,omitempty"`
}

// ProjectUsage プロジェクトにおける特定 OSS バージョンの利用レコード
type ProjectUsage struct {
	// AddedAt 登録日時
	AddedAt time.Time `json:"addedAt"`

	// DirectDependency 直接依存なら true (間接は false)
	DirectDependency bool `json:"directDependency"`

	// EvaluatedAt スコープ判定更新日時
	EvaluatedAt *time.Time `json:"evaluatedAt"`

	// EvaluatedBy 判定実施ユーザ
	EvaluatedBy *string `json:"evaluatedBy"`

	// ForkOriginUrl フォーク元 URL (INTERNAL_FORK の場合)
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// Id 利用 ID
	Id openapi_types.UUID `json:"id"`

	// InclusionNote IN/OUT 判断理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// ModificationDescription 改変内容概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified bool `json:"modified"`

	// OssId OSSコンポーネント ID (利便性重複)
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// ProjectId プロジェクト ID
	ProjectId openapi_types.UUID `json:"projectId"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageCreateRequest プロジェクト利用作成リクエスト
type ProjectUsageCreateRequest struct {
	// DirectDependency 直接依存なら true
	DirectDependency *bool `json:"directDependency,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// InclusionNote 初期理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified *bool `json:"modified,omitempty"`

	// OssId OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageUpdateRequest プロジェクト利用更新リクエスト
type ProjectUsageUpdateRequest struct {
	// DirectDependency 直接依存フラグ
	DirectDependency *bool `json:"directDependency,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// InclusionNote 理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified *bool `json:"modified,omitempty"`

	// OssVersionId 新しい OSS バージョン ID
	OssVersionId *openapi_types.UUID `json:"ossVersionId,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole *UsageRole `json:"usageRole,omitempty"`
}

// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
type ReviewStatus string

// Role アクセス制御ロール（ADMIN=全権, EDITOR=編集可, VIEWER=参照のみ）
type Role string

// ScopePolicy スコープ自動判定ポリシー設定
type ScopePolicy struct {
	// AutoMarkForksInScope INTERNAL_FORK を自動 IN_SCOPE 化するか
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// Id ポリシー ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED を自動 IN_SCOPE にするフラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とみなすか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`

	// UpdatedAt 最終更新日時
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UpdatedBy 更新ユーザ
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// ScopePolicyUpdateRequest スコープポリシー更新リクエスト
type ScopePolicyUpdateRequest struct {
	// AutoMarkForksInScope INTERNAL_FORK 自動 IN_SCOPE フラグ
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED 自動 IN_SCOPE フラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とするか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`
}

// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
type ScopeStatus string

// ScopeStatusUpdateRequest スコープ判定更新リクエスト
type ScopeStatusUpdateRequest struct {
	// ReasonCode 理由コード (マスタ化想定)
	ReasonCode *string `json:"reasonCode"`

	// ReasonNote 自由記述理由
	ReasonNote *string `json:"reasonNote"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`
}

// SupplierType 取得・供給形態（フォークや再パッケージか）
type SupplierType string

// Tag OSSコンポーネントに付与する分類タグ
type Tag struct {
	// CreatedAt 作成日時
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id タグ ID
	Id openapi_types.UUID `json:"id"`

	// Name タグ名称（ユニーク）
	Name string `json:"name"`
}

// TagCreateRequest タグ作成リクエスト
type TagCreateRequest struct {
	// Name タグ名称
	Name string `json:"name"`
}

// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
type UsageRole string

// User システム利用ユーザー情報
type User struct {
	// Active 有効/無効フラグ
	Active bool `json:"active"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Id ユーザーID
	Id openapi_types.UUID `json:"id"`

	// Roles 付与ロール一覧
	Roles []Role `json:"roles"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Username ログインID（ユニーク）
	Username string `json:"username"`
}

// UserCreateRequest ユーザー作成リクエスト
type UserCreateRequest struct {
	// Active 有効化フラグ
	Active *bool `json:"active,omitempty"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Password 初期パスワード（JWTでも登録時のみ使用可）
	Password *string `json:"password,omitempty"`

	// Roles 付与するロール一覧
	Roles []Role `json:"roles"`

	// Username ログインID
	Username string `json:"username"`
}

// UserUpdateRequest ユーザー更新リクエスト（部分）
type UserUpdateRequest struct {
	// Active 有効/無効切替
	Active *bool `json:"active,omitempty"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Password パスワード再設定用（任意）
	Password *string `json:"password,omitempty"`

	// Roles 付与ロール一覧（管理者のみ変更可）
	Roles *[]Role `json:"roles,omitempty"`
}

// PageParam defines model for PageParam.
type PageParam = int

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = string

// BadRequest RFC 9457 / RFC 7807 型エラー応答ボディ
type BadRequest = Problem

// Forbidden RFC 9457 / RFC 7807 型エラー応答ボディ
type Forbidden = Problem

// NotFound RFC 9457 / RFC 7807 型エラー応答ボディ
type NotFound = Problem

// Unauthorized RFC 9457 / RFC 7807 型エラー応答ボディ
type Unauthorized = Problem

// SearchAuditLogsParams defines parameters for SearchAuditLogs.
type SearchAuditLogsParams struct {
	EntityType *string    `form:"entityType,omitempty" json:"entityType,omitempty"`
	EntityId   *string    `form:"entityId,omitempty" json:"entityId,omitempty"`
	From       *time.Time `form:"from,omitempty" json:"from,omitempty"`
	To         *time.Time `form:"to,omitempty" json:"to,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// Password パスワード
	Password string `json:"password"`

	// Username ログインID
	Username string `json:"username"`
}

// ListOssComponentsParams defines parameters for ListOssComponents.
type ListOssComponentsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Sort ソート指定 (例: name,asc / createdAt,desc)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Name 部分一致
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Layers カンマ区切り Layer フィルタ (例 LIB,DB)
	Layers *string `form:"layers,omitempty" json:"layers,omitempty"`

	// Tag タグ名 (正確一致)
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// InScopeOnly true の場合 IN_SCOPE のバージョンを一つ以上持つもののみ
	InScopeOnly *bool `form:"inScopeOnly,omitempty" json:"inScopeOnly,omitempty"`
}

// ListOssVersionsParams defines parameters for ListOssVersions.
type ListOssVersionsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size         *SizeParam    `form:"size,omitempty" json:"size,omitempty"`
	ReviewStatus *ReviewStatus `form:"reviewStatus,omitempty" json:"reviewStatus,omitempty"`
	ScopeStatus  *ScopeStatus  `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`
	Code *string    `form:"code,omitempty" json:"code,omitempty"`
	Name *string    `form:"name,omitempty" json:"name,omitempty"`
}

// ExportProjectArtifactsParams defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParams struct {
	Format ExportProjectArtifactsParamsFormat `form:"format" json:"format"`
	Scopes *string                            `form:"scopes,omitempty" json:"scopes,omitempty"`
}

// ExportProjectArtifactsParamsFormat defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParamsFormat string

// ListProjectUsagesParams defines parameters for ListProjectUsages.
type ListProjectUsagesParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size        *SizeParam   `form:"size,omitempty" json:"size,omitempty"`
	ScopeStatus *ScopeStatus `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
	UsageRole   *UsageRole   `form:"usageRole,omitempty" json:"usageRole,omitempty"`

	// Direct 直接依存のみ true
	Direct *bool `form:"direct,omitempty" json:"direct,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Username 部分一致検索
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Role ロールで絞り込み
	Role *Role `form:"role,omitempty" json:"role,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreateOssComponentJSONRequestBody defines body for CreateOssComponent for application/json ContentType.
type CreateOssComponentJSONRequestBody = OssComponentCreateRequest

// UpdateOssComponentJSONRequestBody defines body for UpdateOssComponent for application/json ContentType.
type UpdateOssComponentJSONRequestBody = OssComponentUpdateRequest

// CreateOssVersionJSONRequestBody defines body for CreateOssVersion for application/json ContentType.
type CreateOssVersionJSONRequestBody = OssVersionCreateRequest

// UpdateOssVersionJSONRequestBody defines body for UpdateOssVersion for application/json ContentType.
type UpdateOssVersionJSONRequestBody = OssVersionUpdateRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectCreateRequest

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = ProjectUpdateRequest

// CreateProjectUsageJSONRequestBody defines body for CreateProjectUsage for application/json ContentType.
type CreateProjectUsageJSONRequestBody = ProjectUsageCreateRequest

// UpdateProjectUsageJSONRequestBody defines body for UpdateProjectUsage for application/json ContentType.
type UpdateProjectUsageJSONRequestBody = ProjectUsageUpdateRequest

// UpdateProjectUsageScopeJSONRequestBody defines body for UpdateProjectUsageScope for application/json ContentType.
type UpdateProjectUsageScopeJSONRequestBody = ScopeStatusUpdateRequest

// UpdateScopePolicyJSONRequestBody defines body for UpdateScopePolicy for application/json ContentType.
type UpdateScopePolicyJSONRequestBody = ScopePolicyUpdateRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = TagCreateRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreateRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 監査ログ簡易検索 (Phase1簡易)
	// (GET /audit)
	SearchAuditLogs(ctx echo.Context, params SearchAuditLogsParams) error
	// ログイン（JWT発行）
	// (POST /auth/login)
	Login(ctx echo.Context) error
	// ログアウト（アクセストークン無効化／ログ記録用）
	// (POST /auth/logout)
	Logout(ctx echo.Context) error
	// 現在ログイン中ユーザー情報取得
	// (GET /me)
	GetCurrentUser(ctx echo.Context) error
	// OSSコンポーネント一覧取得
	// (GET /oss)
	ListOssComponents(ctx echo.Context, params ListOssComponentsParams) error
	// OSSコンポーネント作成
	// (POST /oss)
	CreateOssComponent(ctx echo.Context) error
	// OSSコンポーネントを非推奨 (deprecated=true) に設定
	// (DELETE /oss/{ossId})
	DeprecateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント詳細
	// (GET /oss/{ossId})
	GetOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント更新 (部分)
	// (PATCH /oss/{ossId})
	UpdateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// 指定 OSS のバージョン一覧
	// (GET /oss/{ossId}/versions)
	ListOssVersions(ctx echo.Context, ossId openapi_types.UUID, params ListOssVersionsParams) error
	// バージョン追加
	// (POST /oss/{ossId}/versions)
	CreateOssVersion(ctx echo.Context, ossId openapi_types.UUID) error
	// バージョン削除 (論理/物理は実装方針による)
	// (DELETE /oss/{ossId}/versions/{versionId})
	DeleteOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン詳細
	// (GET /oss/{ossId}/versions/{versionId})
	GetOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン更新
	// (PATCH /oss/{ossId}/versions/{versionId})
	UpdateOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// プロジェクト一覧
	// (GET /projects)
	ListProjects(ctx echo.Context, params ListProjectsParams) error
	// プロジェクト作成
	// (POST /projects)
	CreateProject(ctx echo.Context) error
	// プロジェクト削除 (論理予定)
	// (DELETE /projects/{projectId})
	DeleteProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト詳細
	// (GET /projects/{projectId})
	GetProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト更新
	// (PATCH /projects/{projectId})
	UpdateProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト納品用エクスポート (プレースホルダ)
	// (GET /projects/{projectId}/export)
	ExportProjectArtifacts(ctx echo.Context, projectId openapi_types.UUID, params ExportProjectArtifactsParams) error
	// プロジェクト中利用 OSS 一覧
	// (GET /projects/{projectId}/usages)
	ListProjectUsages(ctx echo.Context, projectId openapi_types.UUID, params ListProjectUsagesParams) error
	// プロジェクト利用追加
	// (POST /projects/{projectId}/usages)
	CreateProjectUsage(ctx echo.Context, projectId openapi_types.UUID) error
	// 利用削除
	// (DELETE /projects/{projectId}/usages/{usageId})
	DeleteProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 利用情報更新
	// (PATCH /projects/{projectId}/usages/{usageId})
	UpdateProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// スコープ判定更新
	// (PATCH /projects/{projectId}/usages/{usageId}/scope)
	UpdateProjectUsageScope(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 現行スコープポリシー取得
	// (GET /scope/policy)
	GetScopePolicy(ctx echo.Context) error
	// スコープポリシー更新 (管理者)
	// (PATCH /scope/policy)
	UpdateScopePolicy(ctx echo.Context) error
	// タグ一覧
	// (GET /tags)
	ListTags(ctx echo.Context) error
	// タグ作成
	// (POST /tags)
	CreateTag(ctx echo.Context) error
	// タグ削除
	// (DELETE /tags/{tagId})
	DeleteTag(ctx echo.Context, tagId openapi_types.UUID) error
	// ユーザー一覧
	// (GET /users)
	ListUsers(ctx echo.Context, params ListUsersParams) error
	// ユーザー作成
	// (POST /users)
	CreateUser(ctx echo.Context) error
	// ユーザー削除 (論理/物理は実装次第)
	// (DELETE /users/{userId})
	DeleteUser(ctx echo.Context, userId openapi_types.UUID) error
	// ユーザー詳細
	// (GET /users/{userId})
	GetUser(ctx echo.Context, userId openapi_types.UUID) error
	// ユーザー更新
	// (PATCH /users/{userId})
	UpdateUser(ctx echo.Context, userId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAuditLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAuditLogsParams
	// ------------- Optional query parameter "entityType" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityType", ctx.QueryParams(), &params.EntityType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityType: %s", err))
	}

	// ------------- Optional query parameter "entityId" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityId", ctx.QueryParams(), &params.EntityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityId: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchAuditLogs(ctx, params)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// ListOssComponents converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssComponents(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssComponentsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "layers" -------------

	err = runtime.BindQueryParameter("form", true, false, "layers", ctx.QueryParams(), &params.Layers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter layers: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "inScopeOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "inScopeOnly", ctx.QueryParams(), &params.InScopeOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inScopeOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssComponents(ctx, params)
	return err
}

// CreateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssComponent(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssComponent(ctx)
	return err
}

// DeprecateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) DeprecateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeprecateOssComponent(ctx, ossId)
	return err
}

// GetOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssComponent(ctx, ossId)
	return err
}

// UpdateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssComponent(ctx, ossId)
	return err
}

// ListOssVersions converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssVersions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssVersionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "reviewStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "reviewStatus", ctx.QueryParams(), &params.ReviewStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewStatus: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssVersions(ctx, ossId, params)
	return err
}

// CreateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssVersion(ctx, ossId)
	return err
}

// DeleteOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteOssVersion(ctx, ossId, versionId)
	return err
}

// GetOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssVersion(ctx, ossId, versionId)
	return err
}

// UpdateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssVersion(ctx, ossId, versionId)
	return err
}

// ListProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjects(ctx, params)
	return err
}

// CreateProject converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProject(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProject(ctx)
	return err
}

// DeleteProject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProject(ctx, projectId)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProject(ctx, projectId)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProject(ctx, projectId)
	return err
}

// ExportProjectArtifacts converts echo context to params.
func (w *ServerInterfaceWrapper) ExportProjectArtifacts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportProjectArtifactsParams
	// ------------- Required query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, true, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "scopes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopes", ctx.QueryParams(), &params.Scopes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportProjectArtifacts(ctx, projectId, params)
	return err
}

// ListProjectUsages converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjectUsages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectUsagesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// ------------- Optional query parameter "usageRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "usageRole", ctx.QueryParams(), &params.UsageRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageRole: %s", err))
	}

	// ------------- Optional query parameter "direct" -------------

	err = runtime.BindQueryParameter("form", true, false, "direct", ctx.QueryParams(), &params.Direct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direct: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjectUsages(ctx, projectId, params)
	return err
}

// CreateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProjectUsage(ctx, projectId)
	return err
}

// DeleteProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsageScope converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsageScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsageScope(ctx, projectId, usageId)
	return err
}

// GetScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) GetScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScopePolicy(ctx)
	return err
}

// UpdateScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateScopePolicy(ctx)
	return err
}

// ListTags converts echo context to params.
func (w *ServerInterfaceWrapper) ListTags(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTags(ctx)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, tagId)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateUser(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx, userId)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUser(ctx, userId)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUser(ctx, userId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/audit", wrapper.SearchAuditLogs)
	router.POST(baseURL+"/auth/login", wrapper.Login)
	router.POST(baseURL+"/auth/logout", wrapper.Logout)
	router.GET(baseURL+"/me", wrapper.GetCurrentUser)
	router.GET(baseURL+"/oss", wrapper.ListOssComponents)
	router.POST(baseURL+"/oss", wrapper.CreateOssComponent)
	router.DELETE(baseURL+"/oss/:ossId", wrapper.DeprecateOssComponent)
	router.GET(baseURL+"/oss/:ossId", wrapper.GetOssComponent)
	router.PATCH(baseURL+"/oss/:ossId", wrapper.UpdateOssComponent)
	router.GET(baseURL+"/oss/:ossId/versions", wrapper.ListOssVersions)
	router.POST(baseURL+"/oss/:ossId/versions", wrapper.CreateOssVersion)
	router.DELETE(baseURL+"/oss/:ossId/versions/:versionId", wrapper.DeleteOssVersion)
	router.GET(baseURL+"/oss/:ossId/versions/:versionId", wrapper.GetOssVersion)
	router.PATCH(baseURL+"/oss/:ossId/versions/:versionId", wrapper.UpdateOssVersion)
	router.GET(baseURL+"/projects", wrapper.ListProjects)
	router.POST(baseURL+"/projects", wrapper.CreateProject)
	router.DELETE(baseURL+"/projects/:projectId", wrapper.DeleteProject)
	router.GET(baseURL+"/projects/:projectId", wrapper.GetProject)
	router.PATCH(baseURL+"/projects/:projectId", wrapper.UpdateProject)
	router.GET(baseURL+"/projects/:projectId/export", wrapper.ExportProjectArtifacts)
	router.GET(baseURL+"/projects/:projectId/usages", wrapper.ListProjectUsages)
	router.POST(baseURL+"/projects/:projectId/usages", wrapper.CreateProjectUsage)
	router.DELETE(baseURL+"/projects/:projectId/usages/:usageId", wrapper.DeleteProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId", wrapper.UpdateProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId/scope", wrapper.UpdateProjectUsageScope)
	router.GET(baseURL+"/scope/policy", wrapper.GetScopePolicy)
	router.PATCH(baseURL+"/scope/policy", wrapper.UpdateScopePolicy)
	router.GET(baseURL+"/tags", wrapper.ListTags)
	router.POST(baseURL+"/tags", wrapper.CreateTag)
	router.DELETE(baseURL+"/tags/:tagId", wrapper.DeleteTag)
	router.GET(baseURL+"/users", wrapper.ListUsers)
	router.POST(baseURL+"/users", wrapper.CreateUser)
	router.DELETE(baseURL+"/users/:userId", wrapper.DeleteUser)
	router.GET(baseURL+"/users/:userId", wrapper.GetUser)
	router.PATCH(baseURL+"/users/:userId", wrapper.UpdateUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"SV9b3/8PAAD//8mLtmmsrwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
